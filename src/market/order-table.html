<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<dom-module id="order-table" fit>
    <template>
        <style is="custom-style" include="iron-flex iron-flex-alignment"></style>
        <style include="shared-styles">
            :host {
                display: block;
            }

            paper-progress {
                width: 100%;
                --paper-progress-active-color: var(--app-primary-color);
                --paper-progress-secondary-color: var(--paper-amber-500);
            }

            .red {
                color: var(--app-red-color);
            }

            .green {
                color: var(--app-green-color);
            }

            div.long-hash {
                width: 120px;
            }

            .operations {
                @apply --layout-horizontal;
            }

            .operations a {
                text-align: center;
                padding-left: 4px;
                padding-right: 4px;
            }
        </style>
        <!-- The array is set as the <vaadin-grid>'s "items" property -->
        <global-variable key="app-config" value="{{appConfig}}"></global-variable>
        <global-variable key="settings-relay" value="{{settingsRelay}}"></global-variable>
        <scary-cookie name="settings-relay" value="{{settingsRelay}}"></scary-cookie>
        <vaadin-grid aria-label="Basic Binding Example" items="[[orders]]">
            <vaadin-grid-column width="50px">
                <template class="header">
                    <div class="left-aligned">Hash</div>
                </template>
                <template>
                    <div class="left-aligned">
                        <a href="#/order/[[item.orginalOrder.hash]]">
                            <div class="long-hash"> [[item.orginalOrder.hash]]</div>
                        </a>
                    </div>
                </template>
            </vaadin-grid-column>
            <vaadin-grid-column width="20px">
                <template class="header">Type</template>
                <template>
                    <span class$="[[item.typeClass]]">[[item.typeTitle]]</span>
                </template>
            </vaadin-grid-column>
            <vaadin-grid-column width="50px">
                <template class="header">Amount</template>
                <template>
                    <pretty-number v="[[item.amountS]]" d=[[item.volumnPrecisionS]] postfix="[[item.tokenS]]"></pretty-number>
                </template>
            </vaadin-grid-column>
            <vaadin-grid-column width="50px">
                <template class="header">Price</template>
                <template>
                    <pretty-number v="[[item.price]]" d=[[item.pricePrecision]]></pretty-number>
                </template>
            </vaadin-grid-column>
            <vaadin-grid-column width="50px">
                <template class="header">Size</template>
                <template>
                    <pretty-number v="[[item.amountB]]" d=[[item.volumnPrecisionB]] postfix="[[item.tokenB]]"></pretty-number>
                </template>
            </vaadin-grid-column>
            <vaadin-grid-column width="50px">
                <template class="header">Status</template>
                <template>
                    <div id="progress[[index]]" class="horizontal end-justified layout">
                        <paper-progress value="[[item.totalDealedAmountB]]" secondary-progress="[[item.processed]]" max="[[item.amountB]]"></paper-progress>
                        <paper-tooltip for="progress[[index]]" position="left">
                            <div>
                                <div>Original: [[item.amountS]]</div>
                                <div>Filled: [[item.totalDealedAmountS]]</div>
                                <div>Cancelled: [[item.totalCancelledAmountS]]</div>
                            </div>
                        </paper-tooltip>
                    </div>
                </template>
            </vaadin-grid-column>
            <vaadin-grid-column width="50px">
                <template class="header">
                    <div class="left-aligned">Time</div>
                </template>
                <template>
                    <div class="left-aligned">
                        <time-str seconds="[[item.orginalOrder.timestamp]]"></time-str>
                    </div>
                </template>
            </vaadin-grid-column>
            <vaadin-grid-column hidden$="[[hiddenCancel]]" width="50px">
                <template class="header">
                    <div class="left-aligned">Operations</div>
                </template>
                <template>
                    <div class="operations">
                        <a href="javascript:void(0)" hash="[[item.orginalOrder.hash]]" on-click="_cancel">Cancel</a>
                    </div>
                </template>
            </vaadin-grid-column>
            <paper-progress indeterminate disabled$="{{!loading}}" class="data-loading"></paper-progress>
        </vaadin-grid>
        <iron-ajax auto id="ajax" url="[[relay]]/Loopring/mock-relay-data/master/orders.json" handle-as="json" last-response="{{resp}}" loading="{{loading}}"></iron-ajax>
    </template>
    <script>
    class OrderTable extends AppConfigMixin(Polymer.Element) {
        static get is() {
            return 'order-table';
        }

        static get properties() {
            return {
                market: String,
                displayMode: {
                    type: String
                },
                relay: {
                    type: Object,
                    computed: '_selectedRelay(settingsRelay)'
                },
                orders: {
                    type: Object,
                    computed: '_computeOrders(appConfig, resp)'
                }
            };
        }

        ready(){
            super.ready();
            this.hiddenCancel = true;
            if (this.displayMode) {
                let displayMode = this.displayMode.toLowerCase();
                if ("wallet-orders" === displayMode) {
                    this.hiddenCancel = false;
                }
            }
        }

        _cancel(e){
            console.info(e.target.hash + ' was clicked.');
        }

        _selectedRelay(settingsRelay){
            return settingsRelay;
        }

        _computeOrders(appConfig, resp) {
            if(appConfig && resp && resp.result.data){
                return _.map(resp.result.data, o => this._computeItem(appConfig, o));
            }
        }

        _computeItem(appConfig, order){
            if(this.market){
                let marketConfig = this.getMarket(this.market);
                if(null != marketConfig){
                    order.typeClass = order.orginalOrder.tokenB.toUpperCase() === marketConfig.tokenx ? 'green' : 'red';
                    order.typeTitle = order.orginalOrder.tokenB.toUpperCase() === marketConfig.tokenx ? 'Buy' : 'Sell';
                    if (order.orginalOrder.tokenB.toUpperCase() === marketConfig.tokenx) {
                        let tempS = order.orginalOrder.tokenS,
                            tempB = order.orginalOrder.tokenB,
                            tempAmountS = order.orginalOrder.amountB,
                            tempAmountB = order.orginalOrder.amountS,
                            tempDealedAmountS = order.totalDealedAmountS,
                            tempDealedAmountB = order.totalDealedAmountB;
                        order.orginalOrder.tokenS = tempB;
                        order.orginalOrder.amountS = tempAmountB;
                        order.totalDealedAmountS = tempDealedAmountB;
                        order.orginalOrder.tokenB = tempS;
                        order.totalDealedAmountB = tempDealedAmountS;
                        order.orginalOrder.amountB = tempAmountS;
                    }
                } else {
                    this.dispatchEvent(new CustomEvent('nout-found', { bubbles: true, composed: true, detail: {msg: "not found market:"+this.market} }));
                }
            } else {
                order.typeTitle = order.orginalOrder.tokenS.toUpperCase() + "â‡¢" + order.orginalOrder.tokenB.toUpperCase();
            }
            let precisionB = this._getTokenPrecision(order.orginalOrder.tokenB, appConfig);
            order.tokenB = order.orginalOrder.tokenB.toUpperCase();
            order.amountB = this.numberFormat(order.orginalOrder.amountB);
            order.price = this.getPrice(order.orginalOrder.amountB, order.orginalOrder.amountS);
            order.pricePrecision = precisionB.pricePrecision;
            order.volumnPrecisionB = precisionB.volumnPrecision;
            let precisionS = this._getTokenPrecision(order.orginalOrder.tokenS, appConfig);
            order.tokenS = order.orginalOrder.tokenS.toUpperCase();
            order.amountS = this.numberFormat(order.orginalOrder.amountS);
            order.volumnPrecisionS = precisionS.volumnPrecision;
            order.totalDealedAmountB = this.numberFormat(order.totalDealedAmountB);
            order.totalDealedAmountS = this.numberFormat(order.totalDealedAmountS);
            order.totalCancelledAmountS = this.numberFormat(order.totalCancelledAmountS)
            order.processed = this.testBalance(order.amountB);
            return order;
        }

        _getTokenPrecision(tokenName, appConfig){
            let pricePrecision = appConfig.marketConfig.defaultPricePrecision, volumnPrecision = appConfig.marketConfig.defaultVolumePrecision;
            let marketConfig = this.getMarket(tokenName+"-WETH");
            if (marketConfig) {
                pricePrecision = marketConfig.pricePrecision;
            }
            const tokenxConfig = appConfig.tokenMap[tokenName];
            if (tokenxConfig) {
                volumnPrecision = tokenxConfig.precision;
            }
            return {pricePrecision: pricePrecision, volumnPrecision: volumnPrecision}
        }

        testBalance(num) {
            return 0.6 * num;
        }

        tranHextoNum(hex) {
            if (hex) {
                return Number(hex);
            }
            return 0;
        }

        numberFormat(num) {
            if (!num) return 0;
            const size = this.tranHextoNum(num);
            return size / 1000000000000000000;
        }

        getPrice(b, s) {
            if (b && s && s !== 0) {
                return (b / s);
            }
            return 0;
        }

        go() {
            this.$.ajax.generateRequest();
        }
    }

    window.customElements.define(OrderTable.is, OrderTable);
    </script>
</dom-module>